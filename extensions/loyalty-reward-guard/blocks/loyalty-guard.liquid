{% schema %}
{
  "name": "Loyalty Reward Guard",
  "target": "body",
  "settings": []
}
{% endschema %}

{% assign notification_message = 'notification' | t %}

<script>
  (function () {
    const NOTIFICATION_MESSAGE = {{ notification_message | json }};
    const REWARD_ITEMS_CACHE_KEY = 'loyalty_guard_reward_items';

    // ---------- –ö–≠–® –ù–ê–ì–†–ê–î–ù–´–• –í–ê–†–ò–ê–ù–¢–û–í (variant_id) –í localStorage ----------

    function getRewardItemsCache() {
      try {
        const cached = localStorage.getItem(REWARD_ITEMS_CACHE_KEY);
        return cached ? JSON.parse(cached) : [];
      } catch (e) {
        return [];
      }
    }

    function setRewardItemsCache(variantIds) {
      try {
        localStorage.setItem(REWARD_ITEMS_CACHE_KEY, JSON.stringify(variantIds));
      } catch (e) {}
    }

    // ---------- –ß–¢–ï–ù–ò–ï –ö–û–†–ó–ò–ù–´ /cart.js ----------

    async function getCart() {
      try {
        return await fetch("/cart.js").then(r => r.json());
      } catch (e) {
        return { items: [] };
      }
    }

    // ---------- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–≠–®–ê –ù–ê–ì–†–ê–î–ù–´–• –¢–û–í–ê–†–û–í ----------

    async function initializeRewardItemsCache() {
      const cart = await getCart();
      const rewardVariantIds = [];

      // 1) –í–∞—Ä–∏–∞–Ω—Ç—ã –∏–∑ cart.attributes._loyalty_free_items (GID-—Å–ø–∏—Å–æ–∫)
      if (cart.attributes && cart.attributes._loyalty_free_items) {
        try {
          const freeItems = JSON.parse(cart.attributes._loyalty_free_items);
          freeItems.forEach(gid => {
            const variantId = gid.split('/').pop();
            if (variantId) rewardVariantIds.push(String(variantId));
          });
        } catch (e) {}
      }

      // 2) –í–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ —Ç–µ–≥—É reward_item
      for (const item of cart.items || []) {
        if (!item.product || !item.product.tags) continue;

        const tags = item.product.tags;
        const hasRewardTag = Array.isArray(tags)
          ? tags.includes("reward_item")
          : (typeof tags === "string" && tags.includes("reward_item"));

        if (hasRewardTag && !rewardVariantIds.includes(String(item.variant_id))) {
          rewardVariantIds.push(String(item.variant_id));
        }
      }

      if (rewardVariantIds.length > 0) {
        setRewardItemsCache(rewardVariantIds);
      }
    }

    initializeRewardItemsCache();

    // –ü—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–æ—Ä–∑–∏–Ω—ã (–µ—Å–ª–∏ —Ç–µ–º–∞ —Ç—Ä–∏–≥–≥–µ—Ä–∏—Ç —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ) ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
    document.addEventListener('cart:updated', function() {
      initializeRewardItemsCache();
      lockRewardQtyUI(); // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –∑–∞–Ω–æ–≤–æ –±–ª–æ–∫–∏—Ä—É–µ–º UI
    });

    // ---------- –ü–†–û–í–ï–†–ö–ê, –ß–¢–û –¢–û–í–ê–† ‚Äî –ù–ê–ì–†–ê–î–ù–´–ô ----------

    async function hasRewardTag(item) {
      if (!item) return false;

      // 1) –±—ã—Å—Ç—Ä—ã–π –ø—É—Ç—å —á–µ—Ä–µ–∑ localStorage –∫—ç—à
      const cachedRewardItems = getRewardItemsCache();
      if (cachedRewardItems.includes(String(item.variant_id))) {
        return true;
      }

      const cart = await getCart();

      // 2) —á–µ—Ä–µ–∑ cart.attributes._loyalty_free_items
      if (cart.attributes && cart.attributes._loyalty_free_items) {
        try {
          const freeItems = JSON.parse(cart.attributes._loyalty_free_items);
          const variantGid = `gid://shopify/ProductVariant/${item.variant_id}`;

          if (freeItems.includes(variantGid)) {
            if (!cachedRewardItems.includes(String(item.variant_id))) {
              cachedRewardItems.push(String(item.variant_id));
              setRewardItemsCache(cachedRewardItems);
            }
            return true;
          }
        } catch (e) {}
      }

      // 3) –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–≥–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ item.product)
      let tagsToCheck = null;

      if (item.product && item.product.tags) {
        tagsToCheck = item.product.tags;
      } else {
        // fallback: –∑–∞–ø—Ä–æ—Å /products/{handle}.js
        try {
          const productHandle =
            item.handle ||
            (item.url && item.url.split('/products/')[1]?.split('?')[0]);

          if (productHandle) {
            const productRes = await fetch(`/products/${productHandle}.js`);
            if (productRes.ok) {
              const productData = await productRes.json();
              tagsToCheck = productData.tags;
            }
          }
        } catch (e) {}
      }

      if (tagsToCheck) {
        let hasTag = false;

        if (Array.isArray(tagsToCheck)) {
          hasTag = tagsToCheck.includes("reward_item");
        } else if (typeof tagsToCheck === "string") {
          hasTag = tagsToCheck.includes("reward_item");
        }

        if (hasTag) {
          const cachedRewardItems2 = getRewardItemsCache();
          if (!cachedRewardItems2.includes(String(item.variant_id))) {
            cachedRewardItems2.push(String(item.variant_id));
            setRewardItemsCache(cachedRewardItems2);
          }
          return true;
        }
      }

      return false;
    }

    // ---------- –ü–û–õ–£–ß–ò–¢–¨ –ò–ù–§–û –ü–û –¢–û–í–ê–†–£ –î–õ–Ø –ò–ó–ú–ï–ù–ï–ù–ò–Ø –ö–û–õ–ò–ß–ï–°–¢–í–ê ----------

    async function checkRewardItem(keyOrLine, quantity) {
      const cart = await getCart();
      let item = null;

      if (typeof keyOrLine === "string" && keyOrLine.startsWith("gid://")) {
        // variant GID (—Ä–µ–∑–µ—Ä–≤)
        const variantId = parseInt(keyOrLine.split("/").pop(), 10);
        item = cart.items.find(i => i.variant_id === variantId);
      } else if (typeof keyOrLine === "string") {
        // key —Å—Ç—Ä–æ–∫–∏
        item = cart.items.find(i => i.key === keyOrLine);
      } else if (typeof keyOrLine === "number") {
        // line –Ω–æ–º–µ—Ä
        item = cart.items[keyOrLine - 1];
      }

      if (!item) return null;

      const isReward = await hasRewardTag(item);

      return {
        item,
        key: item.key,
        currentQty: item.quantity,
        requestedQty: Number(quantity),
        isReward
      };
    }

    // ---------- –õ–û–ì–ò–ö–ê: –ù–£–ñ–ù–û –õ–ò –ë–õ–û–ö–ò–†–û–í–ê–¢–¨ ----------

    function shouldBlock(check) {
      if (!check || !check.isReward) return false;

      const { requestedQty, currentQty } = check;

      // –†–∞–∑—Ä–µ—à–∞–µ–º:
      if (requestedQty === 0) return false;            // —É–¥–∞–ª–µ–Ω–∏–µ
      if (requestedQty < currentQty) return false;     // —É–º–µ–Ω—å—à–µ–Ω–∏–µ
      if (requestedQty === currentQty) return false;   // –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π

      // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ
      if (requestedQty > currentQty) return true;

      return false;
    }

    // ---------- UI: –ë–õ–û–ö–ò–†–£–ï–ú –ö–ù–û–ü–ö–ò / INPUT –î–õ–Ø –ù–ê–ì–†–ê–î–ù–´–• –¢–û–í–ê–†–û–í ----------

    function lockRewardQtyUI() {
      const rewardVariantIds = getRewardItemsCache();
      if (!rewardVariantIds.length) return;

      // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–∫—Ä—ã—Ç—å OS 2.0 —Ç–µ–º—ã (Dawn –∏ –ø–æ–¥–æ–±–Ω—ã–µ)
      const cartItems = document.querySelectorAll("[data-cart-item], .cart-item, .cart-item__outer");

      cartItems.forEach(itemEl => {
        if (itemEl.dataset.loyaltyGuardLocked === "true") return;

        let variantId = itemEl.getAttribute("data-variant-id");

        if (!variantId) {
          const idInput = itemEl.querySelector('input[name="id"]');
          if (idInput && idInput.value) {
            variantId = idInput.value;
          }
        }

        if (!variantId) return;

        if (!rewardVariantIds.includes(String(variantId))) return;

        // –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π
        itemEl.dataset.loyaltyGuardLocked = "true";

        // –ë–ª–æ–∫–∏—Ä—É–µ–º + –∫–Ω–æ–ø–∫–∏
        const buttons = itemEl.querySelectorAll("button");
        buttons.forEach(btn => {
          const label = btn.getAttribute("aria-label") || "";
          const text = btn.textContent.trim();
          const name = btn.getAttribute("name") || "";

          const isPlus =
            name.toLowerCase() === "plus" ||
            label.toLowerCase().includes("increase") ||
            label.toLowerCase().includes("augmenter") ||
            text === "+" ||
            btn.classList.contains("quantity__button--plus");

          if (isPlus) {
            btn.disabled = true;
            btn.style.opacity = "0.5";
            btn.style.cursor = "not-allowed";
          }
        });

        // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ä—É—á–Ω–æ–π –≤–≤–æ–¥
        const qtyInputs = itemEl.querySelectorAll('input[type="number"], input[name^="updates"]');
        qtyInputs.forEach(inp => {
          inp.readOnly = true;
          inp.style.background = "#f6f6f6";
          inp.style.cursor = "not-allowed";
        });

        // –ú–∞–ª–µ–Ω—å–∫–∏–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π –º–∞—Ä–∫–µ—Ä (–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å)
        itemEl.style.position = itemEl.style.position || "relative";
        const lock = document.createElement("div");
        lock.textContent = "üîí";
        lock.style.position = "absolute";
        lock.style.right = "6px";
        lock.style.top = "4px";
        lock.style.fontSize = "14px";
        lock.style.opacity = "0.8";
        itemEl.appendChild(lock);
      });
    }

    // –ü–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ UI-–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    document.addEventListener("DOMContentLoaded", lockRewardQtyUI);

    // –¢—Ä–µ–∫–∞–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (drawer-cart, AJAX –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
    const observer = new MutationObserver(() => {
      lockRewardQtyUI();
    });
    observer.observe(document.documentElement || document.body, {
      childList: true,
      subtree: true
    });

    // ---------- –ü–ï–†–ï–•–í–ê–¢ FETCH ----------

    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const [url, config] = args;

      const isCartChange = url.includes("/cart/change") || url.includes("/cart/change.js");
      const isCartUpdate = url.includes("/cart/update") || url.includes("/cart/update.js");

      if (!isCartChange && !isCartUpdate) {
        return originalFetch(...args);
      }

      let parsed = {};
      const body = config?.body || "";
      let isJsonBody = false;

      try {
        parsed = JSON.parse(body);
        isJsonBody = true;
      } catch (e) {
        const p = new URLSearchParams(body);
        parsed = Object.fromEntries(p.entries());
        isJsonBody = false;
      }

      if (isCartChange) {
        const line = parsed.line;
        const key = parsed.key || parsed.id;
        const quantity = parsed.quantity;

        if (quantity !== undefined) {
          const identifier = key || (line ? Number(line) : null);
          const check = await checkRewardItem(identifier, quantity);

          if (shouldBlock(check)) {
            alert(NOTIFICATION_MESSAGE);

            const modifiedParsed = {
              ...parsed,
              quantity: check.currentQty
            };

            const newBody = isJsonBody
              ? JSON.stringify(modifiedParsed)
              : new URLSearchParams(modifiedParsed).toString();

            const newConfig = { ...config, body: newBody };

            return originalFetch(url, newConfig);
          }
        }
      }

      if (isCartUpdate && parsed.updates) {
        for (const [itemKey, quantity] of Object.entries(parsed.updates)) {
          const check = await checkRewardItem(itemKey, quantity);

          if (shouldBlock(check)) {
            alert(NOTIFICATION_MESSAGE);

            const modifiedUpdates = { ...parsed.updates };
            modifiedUpdates[check.key] = check.currentQty;

            const modifiedParsed = { ...parsed, updates: modifiedUpdates };
            const newBody = isJsonBody
              ? JSON.stringify(modifiedParsed)
              : new URLSearchParams(modifiedParsed).toString();

            const newConfig = { ...config, body: newBody };

            return originalFetch(url, newConfig);
          }
        }
      }

      return originalFetch(...args);
    };

    // ---------- –ü–ï–†–ï–•–í–ê–¢ XHR (Drawer-cart –∏ —Å—Ç–∞—Ä—ã–µ —Ç–µ–º—ã) ----------

    const originalOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function (method, url) {
      this._url = url;
      originalOpen.apply(this, arguments);
    };

    const originalSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = async function (body) {
      const url = this._url || "";

      const isCartChange = url.includes("/cart/change") || url.includes("/cart/change.js");
      const isCartUpdate = url.includes("/cart/update") || url.includes("/cart/update.js");

      if (!isCartChange && !isCartUpdate) {
        return originalSend.call(this, body);
      }

      let parsed = {};
      let isJsonBody = false;

      try {
        parsed = JSON.parse(body);
        isJsonBody = true;
      } catch (e) {
        const p = new URLSearchParams(body);
        parsed = Object.fromEntries(p.entries());
        isJsonBody = false;
      }

      if (isCartChange) {
        const line = parsed.line;
        const key = parsed.key || parsed.id;
        const quantity = parsed.quantity;

        if (quantity !== undefined) {
          const identifier = key || (line ? Number(line) : null);
          const check = await checkRewardItem(identifier, quantity);

          if (shouldBlock(check)) {
            alert(NOTIFICATION_MESSAGE);

            const modifiedParsed = {
              ...parsed,
              quantity: check.currentQty
            };

            const newBody = isJsonBody
              ? JSON.stringify(modifiedParsed)
              : new URLSearchParams(modifiedParsed).toString();

            return originalSend.call(this, newBody);
          }
        }
      }

      if (isCartUpdate && parsed.updates) {
        let needsModification = false;
        const modifiedUpdates = { ...parsed.updates };

        for (const [itemKey, quantity] of Object.entries(parsed.updates)) {
          const check = await checkRewardItem(itemKey, quantity);

          if (shouldBlock(check)) {
            alert(NOTIFICATION_MESSAGE);
            modifiedUpdates[check.key] = check.currentQty;
            needsModification = true;
          }
        }

        if (needsModification) {
          const modifiedParsed = { ...parsed, updates: modifiedUpdates };
          const newBody = isJsonBody
            ? JSON.stringify(modifiedParsed)
            : new URLSearchParams(modifiedParsed).toString();

          return originalSend.call(this, newBody);
        }
      }

      return originalSend.call(this, body);
    };

  })();
</script>
